#!/bin/bash -e
# Automatically submits a change in Gerrit if change has a reviewer 'autosubmit'.
# If necessary the change gets rebased automatically.

AUTOSUBMIT=autosubmit
GERRIT_SITE=~/review_site
GERRIT=localhost
GERRITPUSH=localhost_autosubmit
GERRITPORT=59418
WORKDIR=$GERRIT_SITE/tmp/autosubmit
SCRIPTDIR=$(pwd)/$(dirname "$0")
CHANGEINFOFILE=$WORKDIR/changeinfo
LOGFILE=$GERRIT_SITE/logs/autosubmit.log

trap 'echo "$0: line ${LINENO}: exit status: $?"' ERR

[ -d $WORKDIR ] || mkdir -p $WORKDIR
[ -d $(dirname $LOGFILE) ] || mkdir -p $(dirname $LOGFILE)
declare -A currentChanges

if [ "$1" = "--debug" ]; then
	DEBUG=1
fi

log()
{
	echo
	echo "$(date +%H:%M:%S): $(basename $0) $CHANGE_NO: $@" >> $LOGFILE
}

debug()
{
	[ $DEBUG ] && echo "$(date +%H:%M:%S): $(basename $0) $CHANGE_NO: $@" >> $LOGFILE
	return 0
}

executeGerritCommand()
{
	ssh -l "Gerrit Code Review" -p $GERRITPORT localhost -i $GERRIT_SITE/etc/ssh_host_dsa_key \
		suexec --as $AUTOSUBMIT -- "$@"
}

getChangeInfo()
{
	executeGerritCommand gerrit query --format JSON --current-patch-set $CHANGE_ID > $CHANGEINFOFILE
}

getChangeState()
{
	cat $CHANGEINFOFILE | $SCRIPTDIR/getjson.py "status"
}

getSubmitState()
{
	executeGerritCommand gerrit test-submit-rule --format json_compact $CHANGE_ID | $SCRIPTDIR/getjson.py "status"
}

getLatestPatchSet()
{
	grep -o refs/changes/[0-9/]* $CHANGEINFOFILE
}

getCommit()
{
	cat $CHANGEINFOFILE | $SCRIPTDIR/getjson.py "currentPatchSet" "revision"
}

checkIfChangeIsSubmittable()
{
	# Check if current change has 'autosubmit' as reviewer
	debug "Check for autosubmit as reviewer"
	GREPARG=\"number\":\"$CHANGE_NO\"
	if ! executeGerritCommand gerrit query --format JSON status:open reviewer:$AUTOSUBMIT | grep -q $GREPARG; then
		log "Autosubmit user not assigned. Exiting."
		return 1
	fi

	getChangeInfo

	# Check that change isn't merged yet
	debug "Check merge state"
	CHANGESTATE=$(getChangeState)
	if [ "$CHANGESTATE" != "NEW" ] && [ "$CHANGESTATE" != "SUBMITTED" ]; then
		log "Change $CHANGE_ID is not open. Exiting."
		return 2
	fi

	# Check if change is ready to be submitted
	debug "Check if ready to submit"
	SUBMITSTATE=$(getSubmitState)

	if [ "$SUBMITSTATE" != "OK" ]; then
		log "Change $CHANGE_ID not ready for submit. Exiting."
		return 3
	fi

	return 0
}

submitOrRebase()
{
	# Try to submit
	debug "Try to submit"
	executeGerritCommand gerrit review --submit "$(getCommit)"

	getChangeInfo
	if [ "$(getChangeState)" = "MERGED" ]; then
		log "Change $CHANGE_ID merged successfully."
		return 0
	fi

	# Submit failed. Try to rebase.
	debug "Submit failed. Trying to rebase"
	[ ! -d "$WORKDIR" ] && mkdir -p "$WORKDIR"

	unset GIT_DIR
	cd "$WORKDIR"
	if [ ! -d "$WORKDIR/$PROJECT" ]; then
		debug "Cloning project $PROJECT"
		git clone git://$GERRIT/$PROJECT
		cd $PROJECT
		git remote set-url --push origin "ssh://$GERRITPUSH/$PROJECT.git"
	fi
	cd "$WORKDIR/$PROJECT"

	debug "Checkout change: git fetch git://$GERRIT/$PROJECT $(getLatestPatchSet) && git checkout FETCH_HEAD"
	git reset -q --hard origin/$BRANCH
	git fetch -q origin 2>> $LOGFILE
	git fetch -q git://$GERRIT/$PROJECT $(getLatestPatchSet) 2>> $LOGFILE && git checkout -q FETCH_HEAD

	debug "Check parent commit is merged"
	if [ $(git log --pretty=format:%H origin/$BRANCH..HEAD | wc -w) -gt 1 ]; then
		log "Merge parent commit first. Exiting."
		return 0
	fi

	debug "Rebase on origin/$BRANCH"
	if ! git rebase -q origin/$BRANCH 2>> $LOGFILE > /dev/null; then
		git rebase --abort
		debug "Rebase failed. Notifying user"
		echo "Rebasing change $CHANGE_ID ($CHANGE_URL) titled \"$(git log --pretty=format:%s -1 HEAD)\" failed.
	Please rebase locally and then send for review." | mail -s "AUTOSUBMIT: rebase failed" "$EMAIL" 2>> $LOGFILE
		return 0
	fi

	debug "Pushing rebased change for review"
	git push -q origin HEAD:refs/for/$BRANCH/$TOPIC 2>> $LOGFILE

	log "Uploaded rebased change for review"
	return 1
}

processChange()
{
	if [ -n "${currentChanges[$PROJECT]}" ] && [ "${currentChanges[$PROJECT]}" != "$CHANGE_NO" ]; then
		debug "Waiting for change ${currentChanges[$PROJECT]}, but current change is $CHANGE_NO; skipping"
		echo "wrong change"
		return
	fi

	debug "Processing change $CHANGE_NO"
	currentChanges[$PROJECT]=""
	if ! checkIfChangeIsSubmittable; then
		echo "not submittable"
		return
	fi
	debug "Change is good; trying to submit"
	if ! submitOrRebase; then
		debug "Setting wait infor for change $CHANGE_NO, project $PROJECT"
		currentChanges[$PROJECT]=$CHANGE_NO
debug "***1"
		echo "rebased"
	else
		echo "merged"
	fi
}

streamEventListener()
{
	local line

	log "Starting stream listener"
	while true
	do
		debug "Waiting for next comment"
		if read -t 300 line; then
			TYPE=$($SCRIPTDIR/getjson.py "type" <<< $line)

			if [ "$TYPE" = "comment-added" ]; then
				# We got a comment. Check if we're assigned as reviewer
				# and if the change is submittable. If it is we (try to)
				# submit it.
				debug "Read line for comment: $line"
				CHANGE_ID=$($SCRIPTDIR/getjson.py "change" "id" <<< $line)
				CHANGE_URL=$($SCRIPTDIR/getjson.py "change" "url" <<< $line)
				CHANGE_NO=$($SCRIPTDIR/getjson.py "change" "number" <<< $line)
				PROJECT=$($SCRIPTDIR/getjson.py "change" "project" <<< $line)
				BRANCH=$($SCRIPTDIR/getjson.py "change" "branch" <<< $line)
				TOPIC=$($SCRIPTDIR/getjson.py "change" "topic" <<< $line)
				EMAIL=$($SCRIPTDIR/getjson.py "change" "owner" "email" <<< $line)

				if [ "$($SCRIPTDIR/getjson.py "comment" <<< $line)" = "" ] && [ "$($SCRIPTDIR/getjson.py "approvals" <<< $line)" = "" ]; then
					debug "Uninteresting comment; skipping"
					continue
				fi
				processChange
debug "***2"
			fi
		else
			# Check all open changes where we are assigned as reviewer. If any change is
			# submittable we (try to) submit it.
			debug "Got timeout waiting for comment. Checking open changes..."
			executeGerritCommand gerrit query --format JSON status:open reviewer:$AUTOSUBMIT | while read line; do
				debug "Found a change waiting for me to review..."
				debug "$line"
				CHANGE_ID=$($SCRIPTDIR/getjson.py "id" <<< $line)
				CHANGE_URL=$($SCRIPTDIR/getjson.py "url" <<< $line)
				CHANGE_NO=$($SCRIPTDIR/getjson.py "number" <<< $line)
				PROJECT=$($SCRIPTDIR/getjson.py "project" <<< $line)
				BRANCH=$($SCRIPTDIR/getjson.py "branch" <<< $line)
				TOPIC=$($SCRIPTDIR/getjson.py "topic" <<< $line)
				EMAIL=$($SCRIPTDIR/getjson.py "owner" "email" <<< $line)

				if  [ "$(processChange)" = "rebased" ]; then
					# we did a rebase, so we have to wait until that's built. We do this
					# by monitoring the incoming comments
					break
				fi
			done
		fi
	debug "***3"
	done
}

#(ssh gerrit2 gerrit stream-events | streamEventListener)&

streamEventListener
